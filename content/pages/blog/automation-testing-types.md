---
layout: PostLayout
metaTitle: null
metaDescription: null
addTitleSuffix: true
socialImage: null
metaTags: []
title: Automation Testing Types
colors: colors-a
date: '2021-10-29'
excerpt: >-
  In the software testing world, there are two types of testing — manual and
  automated testing.
featuredImage:
  type: ImageBlock
  url: /images/header2.jpg
  altText: Automation Testing Types
  caption: Automation Testing Types
bottomSections:
  - type: RecentPostsSection
    colors: colors-c
    elementId: ''
    showDate: true
    showAuthor: true
    showExcerpt: true
    showFeaturedImage: true
    showReadMoreLink: true
    variant: variant-b
    actions:
      - label: See all posts
        altText: See all posts
        url: /blog
        type: Link
        showIcon: true
    styles:
      self:
        height: auto
        width: wide
        padding:
          - pt-10
          - pb-10
          - pl-4
          - pr-4
        justifyContent: center
      title:
        textAlign: left
      subtitle:
        textAlign: left
      actions:
        justifyContent: center
    title: Recent Posts
    subtitle: Some Recent Posts
    recentCount: 3
author: content/data/team/doris-soto.json
---
In the software testing world, there are two types of testing — manual and automated testing.

The aim for both is to execute test cases and take the outcome and compare with them expected results.

Manual testing is the type of testing that requires more human interactions to make sure is doing what it is supposed to do

Manual testing works very good for specific tests cases, but using manual testing takes up a lot of time and has proved to be ineffective over time when a human needs to do the same stuff over and over again.

In the software development world we life in today there are consistent and successive delve-meant cycle and deployments going out, all of this requires a repetitive tests that needs to run to ensure new updates doesn’t break the system.

This is where automation testing comes in. It takes the repetitive side away from the human. Since automation has became a very important step in the development life cycle, many different types of automation has been introduced and with this many robust testing tools have allowed automation testers to simply write new scripts and replay test-suites over and over. This goes with saying, it frees up a lot of time, valuable resources and boost business productivity.

Below is a list of the most popular types of automation tester that any testers should know and be well prepared for it before starting your automation journey.

#### **DIFFERENT TYPES OF AUTOMATION TESTS**

##### **TYPE OF TESTING**

There are 2 main types, functional and non-functional:

**Functional:** is a type of software testing that validates the software system against the functional requirements/specifications. The purpose of Functional tests is to test each function of the software application, by providing appropriate input, verifying the output against the Functional requirements

**Non-functional:** is defined as a type of Software testing to check non-functional aspects (performance, usability, reliability, etc) of a software application. It is designed to test the readiness of a system as per nonfunctional parameters which are never addressed by functional testing. A good example of non-functional test would be to check how many people can simultaneously login into a software.

Below is a list of the most popular types of automation tester that any tester should know and be well prepared for it before starting your automation journey.

**Smoke Tests:** Smoke tests are a type of Functional test that only covers the most important features of software to ensure that it could be further tested without “catching fire,” hence the name Smoke Tests.

**Integration Tests:** Integration tests take all the individual pieces and functionalities of software and test them together as a whole to guarantee smooth operation between all of them.

**Regression Tests:** Regression tests run a combination of Functional and Non-functional tests to check if the software has “regressed” after changes has been made

**Security Tests:** Security tests cover Functional and Non-functional tests that screen the software for any vulnerabilities. They reveal weaknesses and any potential exploit in a system.

**Performance Tests:** Performance tests are often Non-functional tests that help testers evaluate criteria like responsiveness and stability as the software handles load and stress.

**Acceptance Tests:** Acceptance tests are Functional tests that determine how acceptable the software is to the end users. This is the final test a solution must pass before it could be released.

##### **PHASE OF TESTING**

**Unit:** As the name implies, this phase the individual components of a software. Unit testing is the very first phase of testing, usually done by developers before handing the software off to testers, but it could also be automated.

**API:** Application Programming Interface (or API for short) acts as the “middleman” between all of the systems that your software uses, and thus, is then tested after the development process to ensure smooth integration between systems and software. This phase of testing is fairly flexible; it could be conducted either before or after the UI phase, this can be done by either the development or the testing team.

**UI:** Last but not least, User Interface (UI testing) is what the end users see and interact with and, this is usually tested at the very end of the process. This phase of testing is run by testers after the UI of the application has been drafted for the most authentic replication of user experience possible. This is where the business logic of the software is examined and optimised.
